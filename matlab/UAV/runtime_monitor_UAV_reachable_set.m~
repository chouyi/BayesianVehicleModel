clear all;
close all;

%% Input 
update_step = 10;
test_set_start=4200;

%% Load data
pred_step = 5;
pre_com = csvread('../../outputs/ct-model-5-2.csv');
[M,delimiterOut]=importdata('../../data/UAV_data.txt');
[theta,delimiterOut]=importdata('../../data/theta_list.txt');

%% params
omega_max=0.18; 
omega_min=-omega_max;

T=0.4;%discrete time interval dt
para.num_p = 20;%number of omega particals
dim=4;
NT = update_step+1;
training_set_start=test_set_start-1000;
training_set_end = test_set_start;

M_test = M(test_set_start:test_set_start+1+pred_step+NT, :);
M_training = M(training_set_start:training_set_end+pred_step, :);
idx.xy = 3;         idx.xx = 4;         idx.xz = 5;
idx.vy = 6;         idx.vx = 7;         idx.vz = 8;


para.prior_initial=(1/numInt)^np.*ones(1,numInt^np);%@(x) unifpdf(x,omega_min,omega_max);

para.prior_initial=(1/para.num_p)*ones(1,para.num_p^np);%@(x) unifpdf(x,omega_min,omega_max);
para.prior=para.prior_initial;

%% Construct CT model
delta = (omega_max - omega_min)/(2*para.num_p);
CT.A=zeros(4,4,para.num_p);
for i=1:para.num_p
    W=omega_min + delta*(2*i-1); 
    WT=W*T;    
    CT.A(:,:,i)=[1 sin(WT)/W 0 -(1-cos(WT))/W; 0 cos(WT) 0 -sin(WT);...
                0 (1-cos(WT))/W 1 sin(WT)/W; 0 sin(WT) 0 cos(WT)];
end
NT_train=training_set_end- training_set_start;  


%% Real-time part
result_report = zeros(1,3);
t= NT;

% Obstacle setting (at the end of a trajectory)
obs_center = [M_test(t+1+pred_step, idx.xx) M_test(t+1+pred_step, idx.xy)];
obs_zone = make_obstacle(obs_center, 0, 0);
result_report(1,1) = inpolygon(M_test(t+1+pred_step, idx.xx), M_test(t+1+pred_step, idx.xy), obs_zone.Vertices(:,1),obs_zone.Vertices(:,2));

tic;
%% Calc cov matrix
CT.cov=zeros(dim,dim);
for i = 1:NT_train-1
    W_train(i) = atan2(M_training(i+1, idx.vy),M_training(i+1, idx.vx))...
            - atan2(M_training(i, idx.vy)  ,M_training(i, idx.vx));
    if W_train(i) > pi
        W_train(i) = W_train(i) - ceil(W_train(i)/pi)*pi;
    elseif W_train(i) < -pi
        W_train(i) = W_train(i) + ceil(W_train(i)/pi)*pi;
    end
   
    WT=W_train(i)*T;
    
    CT_model = [1 sin(WT)/W_train(i) 0 -(1-cos(WT))/W_train(i); 
                0 cos(WT) 0 -sin(WT);...
                0 (1-cos(WT))/W_train(i) 1 sin(WT)/W_train(i); 
                0 sin(WT) 0 cos(WT)];
            
    error_train(:,i) = [M_training(i+1, idx.xx);M_training(i+1, idx.vx);...
                        M_training(i+1, idx.xy);M_training(i+1, idx.vy)]...
                        -CT_model * [M_training(i, idx.xx);...
                                    M_training(i, idx.vx);...
                                    M_training(i, idx.xy);...
                                    M_training(i, idx.vy)]; 
end
CT.cov = cov(error_train');

x = zeros(dim, NT+1);
for t = 1:NT
    x(:,t) = [M_test(t,idx.xx); M_test(t,idx.vx); M_test(t,idx.xy);M_test(t,idx.vy)];
    x(:,t+1) = [M_test(t+1,idx.xx); M_test(t+1,idx.vx); M_test(t+1,idx.xy);M_test(t+1,idx.vy)];

    post=computePosterior_CTmodel(para,x(:,t),x(:,t+1),CT); 
    para.prior=post;%(1-para.epsilon)*post+para.epsilon*para.prior_initial;

    % Only consider the last position
    if t== NT  
        sum1=0;
        post_theta = [post;theta']';
        post_theta = sortrows(post_theta,1);
        for w_idx=1:para.num_p 
            w=post_theta(w_idx,2);
            [collision, reach_set] = oracle(obs_zone,w, x(2,t+1), x(4,t+1), x(1,t+1), x(3,t+1), pre_com);
            rgb = [1-post_theta(w_idx,1) 1-post_theta(w_idx,1) 1-post_theta(w_idx,1)];

            if collision==1
                sum1=sum1 + post_theta(w_idx,1);
                rgb = [1-post_theta(w_idx,1) 0 0];
            end

            if post_theta(w_idx,1) < 0.01
                continue;
            end
            patch(reach_set.Vertices(:,1)', reach_set.Vertices(:,2)', rgb, 'EdgeColor','none');
            hold on;
        end
        result_report(1,2) = sum1;
    end
end
result_report(1,3) = toc;

patch(obs_zone.Vertices(:,1)', obs_zone.Vertices(:,2)', [0 0.4470 0.7410]);
hold on;
plot(M_test(2:NT+1+pred_step,idx.xx), M_test(2:NT+1+pred_step,idx.xy), '-*k');
hold on;    
plot(M_test(t+1+pred_step, idx.xx), M_test(t+1+pred_step, idx.xy), 'or');
hold on;
set(gca,'DataAspectRatio', [1 1 1]);
    